# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bfMm6krMk7jv2NJKYft-2J3Qh1vEeHpn
"""

#install packages
!pip install dhg

#import packages
import dhg
import torch
import torch.nn as nn
import torch.utils.data as Data
from torch.utils.data import DataLoader, TensorDataset
import torch.nn.functional as F
from dhg.nn import UniGATConv
import pandas as pd
import numpy as np
from dhg.structure.hypergraphs import Hypergraph
import torch.optim as optim
from torch.utils.data import DataLoader, TensorDataset
from sklearn.model_selection import train_test_split
from sklearn.model_selection import KFold
from Function import train,test,data_split

num_cell_lines=13
num_drugs=48

KG_cell_line_feature=pd.read_excel('*path/DATA/KG_cell_line_feature.xlsx').rename(columns={'Unnamed: 0':'cell_line_name'})
drug_feature=pd.read_excel('*path/DATA/drug_feature.xlsx')
extract=pd.read_excel("*path/DATA/extract.xlsx")

cline_feature=KG_cell_line_feature.set_index(['cell_line_name'])
c_map = dict(zip(cline_feature.index, range(num_drugs, num_drugs + num_cell_lines)))

drug_feature=drug_feature.set_index('drug_name')
d_map = dict(zip(drug_feature.index, range(0, num_drugs)))

extract_condition=extract[['drug_row','drug_col','cell_line_name','synergyscore','result']]
syn = [[d_map[str(row[0])], d_map[str(row[1])], c_map[row[2]], float(row[3]),float(row[4])] for index, row in
               extract_condition.iterrows() if (str(row[0]) in drug_feature.index and str(row[1]) in drug_feature.index and
                                           str(row[2]) in cline_feature.index)]

#noise_factor=0.1
cline_feature=np.asarray(cline_feature)
drug_feature=np.asarray(drug_feature)
cline_feature = torch.from_numpy(cline_feature)
#cline_feature = cline_feature + noise_factor * torch.randn_like(cline_feature)
cline_set = Data.DataLoader(dataset=Data.TensorDataset(cline_feature),
                                    batch_size=len(cline_feature), shuffle=False)
drug_feature = torch.from_numpy(drug_feature)
#drug_feature = drug_feature + noise_factor * torch.randn_like(drug_feature)
drug_set = Data.DataLoader(dataset=Data.TensorDataset(drug_feature),
                                    batch_size=len(drug_feature), shuffle=False)

class GATEncoder(torch.nn.Module):
    def __init__(self, in_channels, out_channels):
        super(GATEncoder, self).__init__()
        self.conv =UniGATConv(in_channels, 256)
        self.batch1 = nn.BatchNorm1d(256)
        self.Linear = nn.Linear(256, out_channels)
        self.drop_out = nn.Dropout(0.2)
        self.act = nn.LeakyReLU(0.2)

    def forward(self, x, edge):
        x = self.act(self.conv(x, edge))
        x = self.batch1(x)
        x = self.drop_out(x)
        x = self.act(self.Linear(x))
        return x
class BioEncoder(nn.Module):
    def __init__(self, dim_drug, dim_cellline, output, use_GMP=True):
        super(BioEncoder, self).__init__()

        # -------cell line_layer
        self.fc_cell1 = nn.Linear(dim_cellline, 128)
        self.batch_cell1 = nn.BatchNorm1d(128)
        self.fc_cell2 = nn.Linear(128, output)
        self.drop_out = nn.Dropout(0.1)
        self.act = nn.ReLU()
        # -------drug line_layer
        self.fc_drug1 = nn.Linear(dim_drug, 256)
        self.batch_drug1 = nn.BatchNorm1d(256)
        self.fc_drug2 = nn.Linear(256, output)
        self.drop_out = nn.Dropout(0.2)
        self.act = nn.ReLU()

    def forward(self,gexpr_datadrug, gexpr_datacellline):
        # -----drug_train
        x_drug = self.fc_drug1(gexpr_datadrug.to(self.fc_drug1.weight.dtype))
        x_drug = self.batch_drug1(x_drug)
        x_drug = self.drop_out(x_drug)
        x_drug = self.act(self.fc_drug2(x_drug))
        # ----cellline_train
        x_cellline =self.fc_cell1(gexpr_datacellline.to(self.fc_cell1.weight.dtype))
        x_cellline = self.batch_cell1(x_cellline)
        x_cellline = self.drop_out(x_cellline)
        x_cellline = self.act(self.fc_cell2(x_cellline))
        return x_drug, x_cellline
class Decoder(torch.nn.Module):
    def __init__(self, in_channels):
        super(Decoder, self).__init__()

        self.fc1 = nn.Linear(in_channels, 256)
        self.batch1 = nn.BatchNorm1d(256)
        self.fc2 = nn.Linear(256, 64)
        self.batch2 = nn.BatchNorm1d(64)
        self.fc3 = nn.Linear(64, 16)
        self.batch3 = nn.BatchNorm1d(16)
        self.fc4 = nn.Linear(16, 1)
        self.drop_out = nn.Dropout(0.1)
        self.act = nn.LeakyReLU(0.2)

    def forward(self, graph_embed, druga_id, drugb_id, cellline_id):
        h = torch.cat((graph_embed[druga_id, :], graph_embed[drugb_id, :], graph_embed[cellline_id, :]), 1)
        h = h.float()  # Convert input to float
        h = self.act(self.fc1(h))
        h = self.batch1(h)
        h = self.drop_out(h)
        h = self.act(self.fc2(h))
        h = self.batch2(h)
        h = self.drop_out(h)
        h=self.act(self.fc3(h))
        h=self.batch3(h)
        h = self.fc4(h)
        return h.squeeze(dim=1)

class HyperGraphSynergy(torch.nn.Module):
    def __init__(self, bio_encoder, graph_encoder, decoder):
        super(HyperGraphSynergy, self).__init__()
        self.bio_encoder = bio_encoder
        self.graph_encoder = graph_encoder
        self.decoder = decoder

    def forward(self,gexpr_datadrug ,gexpr_datacellline, adj, druga_id, drugb_id, cellline_id):
        drug_embed, cellline_embed = self.bio_encoder(gexpr_datadrug , gexpr_datacellline)
        merge_embed = torch.cat((drug_embed, cellline_embed), 0)
        graph_embed = self.graph_encoder(merge_embed, adj)
        res = self.decoder(graph_embed, druga_id, drugb_id, cellline_id)
        return res

synergy_data, test_ind, test_label=data_split(syn,rd_seed=3)
data=synergy_data

epochs =1700
learning_rate =2e-4
L2 = 1e-4

final_metric = np.zeros(3)
fold_num = 0
metric_values = []

kf = KFold(n_splits=5, shuffle=True, random_state=0)
for train_index, validation_index in kf.split(data):
    synergy_train, synergy_validation = data[train_index], data[validation_index]
    label_train = torch.from_numpy(np.array(synergy_train[:, 3], dtype='float32'))
    label_validation = torch.from_numpy(np.array(synergy_validation[:, 3], dtype='float32'))
    index_train = torch.from_numpy(synergy_train[:, 0:3]).long()
    index_validation = torch.from_numpy(synergy_validation[:, 0:3]).long()
    # -----construct hyper_synergy_graph_set
    synergy_train_tmp = np.copy(synergy_train)
    my_list = synergy_train_tmp.tolist()
    pos_edge = np.array([t for t in my_list if t[4] == 1])
    edge_data = pos_edge[:, 0:3]
    hyperedge=[tuple(map(int, row)) for row in edge_data]
    hg = dhg.Hypergraph(61,hyperedge)
    # ---model_build
    model = HyperGraphSynergy(BioEncoder(dim_drug=drug_feature.shape[-1], dim_cellline=cline_feature.shape[-1], output=100),
                                      GATEncoder(in_channels=100,out_channels=200), Decoder(in_channels=600))
    loss_func = torch.nn.MSELoss()
    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate, weight_decay=L2)

    for epoch in range(epochs):
        model.train()
        train_metric, train_loss = train(drug_set, cline_set, hg,index_train, label_train)

        val_metric, val_loss,_ = test(drug_set, cline_set, hg,index_validation, label_validation)




    final_metric += val_metric
    fold_num = fold_num + 1
final_metric /= 5
sd=np.std(metric_values, axis=0)
print('Final 5-cv average results, RMSE: {:.6f},'.format(final_metric[0]),
              'R2: {:.6f},'.format(final_metric[1]),
              'Pearson r: {:.6f},'.format(final_metric[2]))# Concatenate the results from all folds